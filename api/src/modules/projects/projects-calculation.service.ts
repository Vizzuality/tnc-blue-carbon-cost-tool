import { Injectable } from '@nestjs/common';
import {
  CalculationEngine,
  CostOutput,
} from '@api/modules/calculations/calculation.engine';
import { DataRepository } from '@api/modules/calculations/data.repository';
import { Project } from '@shared/entities/projects.entity';
import { Country } from '@shared/entities/country.entity';
import { ECOSYSTEM } from '@shared/entities/ecosystem.enum';
import {
  ACTIVITY,
  RESTORATION_ACTIVITY_SUBTYPE,
} from '@shared/entities/activity.enum';
import { CustomProjectFactory } from '@api/modules/custom-projects/input-factory/custom-project.factory';
import { CreateCustomProjectDto } from '@shared/dtos/custom-projects/create-custom-project.dto';
import { ModelAssumptions } from '@shared/entities/model-assumptions.entity';
import { OverridableCostInputs } from '@shared/dtos/custom-projects/cost.inputs';
import { LOSS_RATE_USED } from '@shared/schemas/custom-projects/create-custom-project.schema';
import { EMISSION_FACTORS_TIER_TYPES } from '@shared/entities/carbon-inputs/emission-factors.entity';
import { SEQUESTRATION_RATE_TIER_TYPES } from '@shared/entities/carbon-inputs/sequestration-rate.entity';
import { assumptionsArrayToMap } from '@shared/lib/transform-create-custom-project-payload';
import { CARBON_REVENUES_TO_COVER } from '@shared/entities/custom-project.entity';

// TODO: we need to clearly know which fields are required to create a project, and which are generated by the system
//      do we want to use country code? name? both?
export type CreateProjectDto = {
  projectName: string;
  countryCode: Country['code'];
  ecosystem: ECOSYSTEM;
  activity: ACTIVITY;
  restorationActivity?: RESTORATION_ACTIVITY_SUBTYPE;
  // is this a required field??? there is a project size entity in the DB, but does make sense to not be able to define the size when creating a project
  // from the backoffice, or when importing an excel????
  projectSizeHa: Project['projectSize'];
  priceType: Project['priceType'];
  initialCarbonPriceAssumption: Project['initialPriceAssumption'];
  // TODO: Double check with
};

// TODO: approach for myself, we probably don't need a separate service but I am not sure about the overlapping and different points when computing projects/custom-projects

@Injectable()
export class ProjectsCalculationService {
  constructor(
    private readonly engine: CalculationEngine,
    private readonly dataRepo: DataRepository,
    private readonly customProjectFactory: CustomProjectFactory,
  ) {}

  async computeCostForProject(dto: CreateProjectDto): Promise<CostOutput> {
    const { countryCode, ecosystem, activity, restorationActivity } = dto;
    const {
      defaultAssumptions,
      defaultCostInputs,
      additionalBaseData,
      additionalAssumptions,
      baseSize,
      baseIncrease,
    } = await this.dataRepo.getDataToComputeProjects({
      countryCode,
      ecosystem,
      activity,
      restorationActivity,
    });

    if (dto.initialCarbonPriceAssumption) {
      additionalAssumptions.carbonPrice = dto.initialCarbonPriceAssumption;
    }

    const createDto = this.toCreateCustomProjectDto(dto, {
      defaultAssumptions,
      defaultCostInputs: defaultCostInputs as OverridableCostInputs,
    });

    console.log('CREATE PROJECT DTO');
    console.log({ createDto });

    const projectInput = this.customProjectFactory.createProjectInput(
      createDto,
      additionalBaseData,
      additionalAssumptions,
    );

    const output = this.engine.calculateCostOutput({
      projectInput,
      baseIncrease,
      baseSize,
    });
    return output;
  }

  // TODO: This is not good. We are realizing there are a lot of overlapping points between projects and custom-projects
  toCreateCustomProjectDto(
    dto: CreateProjectDto,
    data: {
      defaultAssumptions: ModelAssumptions[];
      defaultCostInputs: OverridableCostInputs;
    },
  ): CreateCustomProjectDto {
    const parsedAssumptions = assumptionsArrayToMap(data.defaultAssumptions);
    const createDto = {} as CreateCustomProjectDto;
    createDto.activity = dto.activity;
    createDto.countryCode = dto.countryCode;
    createDto.carbonRevenuesToCover = CARBON_REVENUES_TO_COVER.OPEX;
    createDto.ecosystem = dto.ecosystem;
    createDto.projectName = dto.projectName;
    createDto.projectSizeHa = dto.projectSizeHa;
    createDto.initialCarbonPriceAssumption = dto.initialCarbonPriceAssumption;
    createDto.assumptions = parsedAssumptions;
    createDto.costInputs = data.defaultCostInputs;
    // TODO: check how planting success rate is obtained in the FE
    createDto.parameters = this.setDefaultParameters(createDto, {
      plantingSuccessRate: 0.008,
      restorationActivity: dto.restorationActivity,
    });
    return createDto;
  }

  /**
   * @description: It seems that for computing projects, we need to set some default parameters as the tier used and more. this needs to be
   *               clarified with the science team.

   */
  setDefaultParameters(
    dto: CreateCustomProjectDto,
    data: {
      plantingSuccessRate?: number;
      restorationActivity?: RESTORATION_ACTIVITY_SUBTYPE;
    },
  ) {
    const parameters: CreateCustomProjectDto['parameters'] = {
      lossRateUsed:
        dto.ecosystem === ECOSYSTEM.MANGROVE
          ? LOSS_RATE_USED.NATIONAL_AVERAGE
          : undefined,
      plantingSuccessRate: data.plantingSuccessRate,
      tierSelector:
        dto.activity === ACTIVITY.RESTORATION
          ? SEQUESTRATION_RATE_TIER_TYPES.TIER_1
          : undefined,
      emissionFactorUsed:
        dto.activity === ACTIVITY.CONSERVATION
          ? EMISSION_FACTORS_TIER_TYPES.TIER_1
          : undefined,
      restorationActivity:
        dto.activity === ACTIVITY.RESTORATION
          ? data.restorationActivity
          : undefined,
    };
    return parameters;
  }
}
