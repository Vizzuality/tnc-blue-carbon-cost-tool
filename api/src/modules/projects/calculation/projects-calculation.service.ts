import { Injectable } from '@nestjs/common';
import {
  CalculationEngine,
  CalculationInput,
  CostOutput,
} from '@api/modules/calculations/calculation.engine';
import { DataRepository } from '@api/modules/calculations/data.repository';
import { Project } from '@shared/entities/projects.entity';
import { Country } from '@shared/entities/country.entity';
import { ECOSYSTEM } from '@shared/entities/ecosystem.enum';
import {
  ACTIVITY,
  RESTORATION_ACTIVITY_SUBTYPE,
} from '@shared/entities/activity.enum';
import { CustomProjectFactory } from '@api/modules/custom-projects/input-factory/custom-project.factory';
import { ProjectCalculationFactory } from '@api/modules/projects/calculation/project-calculation.factory';
import { ComputationsMicroserviceProxy } from '@api/modules/computations-microservice/computations-microservice.proxy';

// TODO: we need to clearly know which fields are required to create a project, and which are generated by the system
//      do we want to use country code? name? both?
export type CreateProjectDto = {
  projectName: string;
  countryCode: Country['code'];
  ecosystem: ECOSYSTEM;
  activity: ACTIVITY;
  restorationActivity?: RESTORATION_ACTIVITY_SUBTYPE;
  // is this a required field??? there is a project size entity in the DB, but does make sense to not be able to define the size when creating a project
  // from the backoffice, or when importing an excel????
  projectSizeHa: Project['projectSize'];
  priceType: Project['priceType'];
  initialCarbonPriceAssumption: Project['initialPriceAssumption'];
};

@Injectable()
export class ProjectsCalculationService {
  constructor(
    private readonly engine: CalculationEngine,
    private readonly dataRepo: DataRepository,
    private readonly customProjectFactory: CustomProjectFactory,
    private readonly microService: ComputationsMicroserviceProxy,
  ) {}

  async computeCostForProject(dto: CreateProjectDto): Promise<CostOutput> {
    const computationInput = await this.buildDTO(dto);

    const output = this.engine.calculateCostOutput(computationInput);
    return output;
  }

  async computeCostForProjectV2(dto: CreateProjectDto): Promise<CostOutput> {
    const computationInput = await this.buildDTO(dto);

    const output = await this.microService.compute(computationInput);
    return output;
  }

  async buildDTO(dto: CreateProjectDto): Promise<CalculationInput> {
    const { countryCode, ecosystem, activity, restorationActivity } = dto;
    const {
      defaultAssumptions,
      defaultCostInputs,
      additionalBaseData,
      additionalAssumptions,
      baseSize,
      baseIncrease,
    } = await this.dataRepo.getDataToComputeProjects({
      countryCode,
      ecosystem,
      activity,
      restorationActivity,
    });

    if (dto.initialCarbonPriceAssumption) {
      additionalAssumptions.carbonPrice = dto.initialCarbonPriceAssumption;
    }

    const createDTO = new ProjectCalculationFactory(
      dto,
      defaultAssumptions,
      defaultCostInputs,
    ).toCreateCustomProjectDto();

    const projectInput = this.customProjectFactory.createProjectInput(
      createDTO,
      additionalBaseData,
      additionalAssumptions,
    );

    return {
      projectInput,
      baseIncrease,
      baseSize,
    };
  }
}
